# Решения заданий

## Решения для Ученика 1

### Практическое задание:
```python
def get_even_numbers(numbers):
    """
    Возвращает список, содержащий только четные числа из исходного списка.
    
    Args:
        numbers: список чисел
        
    Returns:
        Список четных чисел
    """
    # Используем list comprehension для фильтрации четных чисел
    # Условие number % 2 == 0 проверяет четность числа
    even_numbers = [number for number in numbers if number % 2 == 0]
    return even_numbers

# Пример использования
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = get_even_numbers(numbers)
print(f"Исходный список: {numbers}")
print(f"Четные числа: {result}")
```

### Теоретическое задание:
```
       50
      /  \
     30   70
    / \   / \
   20 40 60 80

Бинарное дерево поиска:
- Для каждой вершины: все элементы в левом поддереве меньше,
  все элементы в правом поддереве больше
- 50 - корень дерева
- 30 < 50, поэтому находится слева
- 70 > 50, поэтому находится справа
- И так далее для всех элементов
```

---

## Решения для Ученика 2

### Практическое задание:
```python
def get_students_above_threshold(students_grades, threshold):
    """
    Возвращает список студентов с оценкой выше заданного порога.
    
    Args:
        students_grades: словарь {имя: оценка}
        threshold: минимальная оценка (не включительно)
        
    Returns:
        Список имен студентов
    """
    # Фильтруем студентов по условию оценки > threshold
    # Метод items() возвращает пары (ключ, значение)
    filtered_students = [
        name for name, grade in students_grades.items() 
        if grade > threshold
    ]
    return filtered_students

# Пример использования
students = {
    "Анна": 85,
    "Борис": 92,
    "Владимир": 78,
    "Дарья": 95,
    "Егор": 88
}

threshold = 85
result = get_students_above_threshold(students, threshold)
print(f"Студенты с оценкой выше {threshold}: {result}")
```

### Теоретическое задание:
```
диаграмма Венна
```

---

## Решения для Ученика 3

### Практическое задание:
```python
def find_intersection(set1, set2):
    """
    Находит пересечение двух множеств (общие элементы).
    
    Args:
        set1: первое множество
        set2: второе множество
        
    Returns:
        Множество общих элементов
    """
    # Используем оператор & для нахождения пересечения
    # Можно также использовать метод intersection()
    intersection = set1 & set2
    return intersection

# Пример использования
set_a = {1, 2, 3, 4, 5}
set_b = {3, 4, 5, 6, 7}
result = find_intersection(set_a, set_b)
print(f"Множество A: {set_a}")
print(f"Множество B: {set_b}")
print(f"Пересечение: {result}")
```

### Теоретическое задание:
```
ОРИЕНТИРОВАННЫЙ ГРАФ:

  A → B
  ↓   ↓
  C → D
  ↑   ↓
  E ← F

Вершины: A, B, C, D, E, F
Ребра:
A→B, A→C, B→D, C→D, D→F, F→E, C→E (можно добавить еще ребро для 6)

Ориентированное ребро обозначается стрелкой.
```

---

## Решения для Ученика 4

### Практическое задание:
```python
def count_characters(text):
    """
    Подсчитывает частоту каждого символа в строке.
    
    Args:
        text: входная строка
        
    Returns:
        Словарь {символ: количество}
    """
    char_count = {}
    
    # Проходим по каждому символу в строке
    for char in text:
        # Если символ уже есть в словаре, увеличиваем счетчик
        # Если нет, добавляем с начальным значением 1
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    
    return char_count

# Пример использования
text = "hello world"
result = count_characters(text)
print(f"Текст: '{text}'")
print(f"Частота символов: {result}")
```

### Теоретическое задание:
```
БИНАРНЫЙ ПОИСК в отсортированном списке [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Ищем элемент 23:

1. Левая граница L=0, правая R=9, середина M=(0+9)//2=4
   Элемент[M]=16, 23>16 → ищем в правой половине
   Новые границы: L=5, R=9

2. M=(5+9)//2=7
   Элемент[M]=56, 23<56 → ищем в левой половине
   Новые границы: L=5, R=6

3. M=(5+6)//2=5
   Элемент[M]=23 == искомому → НАЙДЕНО на позиции 5

Сложность: O(log n)
```

---

## Решения для Ученика 5

### Практическое задание:
```python
def sort_by_age(people):
    """
    Сортирует список кортежей (имя, возраст) по возрасту.
    
    Args:
        people: список кортежей
        
    Returns:
        Отсортированный список
    """
    # Используем функцию sorted с ключом сортировки
    # key=lambda x: x[1] означает сортировка по второму элементу кортежа (возрасту)
    sorted_people = sorted(people, key=lambda x: x[1])
    return sorted_people

# Пример использования
people_list = [
    ("Анна", 25),
    ("Борис", 19),
    ("Владимир", 32),
    ("Дарья", 21),
    ("Егор", 28)
]

result = sort_by_age(people_list)
print("Исходный список:")
for person in people_list:
    print(f"  {person[0]}: {person[1]} лет")

print("\nОтсортированный по возрасту:")
for person in result:
    print(f"  {person[0]}: {person[1]} лет")
```

### Теоретическое задание:
```
Основные методы списков:
1. append(x) - добавить в конец
2. insert(i, x) - вставить на позицию i
3. remove(x) - удалить первый элемент равный x
4. pop() - удалить и вернуть последний элемент
5. pop(i) - удалить и вернуть элемент по индексу i
6. len(list) - длина списка
7. list[i] - получить элемент по индексу
```

---

## Решения для Ученика 6

### Практическое задание:
```python
def lists_to_dict(keys, values):
    """
    Объединяет два списка в словарь.
    
    Args:
        keys: список ключей
        values: список значений
        
    Returns:
        Словарь {ключ: значение}
    """
    # Используем dict comprehension для создания словаря
    # zip(keys, values) создает пары (ключ, значение)
    result_dict = {k: v for k, v in zip(keys, values)}
    return result_dict

# Пример использования
keys_list = ["name", "age", "city", "occupation"]
values_list = ["Анна", 25, "Москва", "инженер"]

result = lists_to_dict(keys_list, values_list)
print(f"Ключи: {keys_list}")
print(f"Значения: {values_list}")
print(f"Словарь: {result}")
```

### Теоретическое задание:
```
СБАЛАНСИРОВАННОЕ дерево:   НЕСБАЛАНСИРОВАННОЕ дерево:
        50                         50
       /  \                       /
      30   70                   30
     / \   / \                 /
    20 40 60 80              20
                           /
                         10
                         /
                        5

Сбалансированное: высота поддеревьев отличается не более чем на 1
Несбалансированное: вырождается в связный список, сложность операций ухудшается
```

---

## Решения для Ученика 7

### Практическое задание:
```python
def remove_duplicates_preserve_order(lst):
    """
    Удаляет дубликаты из списка, сохраняя порядок элементов.
    
    Args:
        lst: исходный список
        
    Returns:
        Список без дубликатов
    """
    # Используем множество для отслеживания уже встреченных элементов
    seen = set()
    result = []
    
    for item in lst:
        if item not in seen:
            seen.add(item)  # Добавляем в множество
            result.append(item)  # Добавляем в результат
    
    return result

# Пример использования
original_list = [1, 2, 3, 2, 4, 1, 5, 3, 6, 2, 7]
result = remove_duplicates_preserve_order(original_list)
print(f"Исходный список: {original_list}")
print(f"Без дубликатов: {result}")
```

### Теоретическое задание:
```
ПУЗЫРЬКОВАЯ СОРТИРОВКА для [5, 3, 8, 4, 2]:

1 проход:
[5, 3, 8, 4, 2] → 5>3 → [3, 5, 8, 4, 2]
[3, 5, 8, 4, 2] → 5<8 → [3, 5, 8, 4, 2]
[3, 5, 8, 4, 2] → 8>4 → [3, 5, 4, 8, 2]
[3, 5, 4, 8, 2] → 8>2 → [3, 5, 4, 2, 8]

2 проход:
[3, 5, 4, 2, 8] → 3<5 → [3, 5, 4, 2, 8]
[3, 5, 4, 2, 8] → 5>4 → [3, 4, 5, 2, 8]
[3, 4, 5, 2, 8] → 5>2 → [3, 4, 2, 5, 8]

3 проход:
[3, 4, 2, 5, 8] → 3<4 → [3, 4, 2, 5, 8]
[3, 4, 2, 5, 8] → 4>2 → [3, 2, 4, 5, 8]

4 проход:
[3, 2, 4, 5, 8] → 3>2 → [2, 3, 4, 5, 8]

Результат: [2, 3, 4, 5, 8]
```

---

## Решения для Ученика 8

### Практическое задание:
```python
def find_second_largest(numbers):
    """
    Находит второй по величине элемент в списке чисел.
    
    Args:
        numbers: список чисел
        
    Returns:
        Второй по величине элемент
    """
    if len(numbers) < 2:
        return None  # Недостаточно элементов
    
    # Инициализируем переменные для наибольшего и второго наибольшего
    largest = second_largest = float('-inf')
    
    for num in numbers:
        if num > largest:
            # Нашли новый наибольший элемент
            second_largest = largest  # Старый наибольший становится вторым
            largest = num
        elif num > second_largest and num != largest:
            # Нашли новый второй наибольший (меньше наибольшего, но больше текущего второго)
            second_largest = num
    
    return second_largest if second_largest != float('-inf') else None

# Пример использования
numbers_list = [10, 5, 8, 20, 15, 12]
result = find_second_largest(numbers_list)
print(f"Список: {numbers_list}")
print(f"Второй по величине элемент: {result}")
```

### Теоретическое задание:
```
СВЯЗНЫЙ СПИСОК:

Исходный:  A → B → C → D

Каждый элемент (узел) содержит:
- данные
- ссылку на следующий элемент

Вставка элемента X между B и C:

1. Создаем элемент X
2. Меняем ссылку B.next с C на X
3. Устанавливаем X.next = C

Результат:  A → B → X → C → D

Преимущества: быстрая вставка/удаление
Недостатки: медленный доступ по индексу
```

---

## Решения для Ученика 9

### Практическое задание:
```python
def is_palindrome(text):
    """
    Проверяет, является ли строка палиндромом.
    
    Args:
        text: строка для проверки
        
    Returns:
        True если палиндром, иначе False
    """
    # Убираем пробелы и приводим к нижнему регистру
    cleaned_text = text.replace(" ", "").lower()
    
    # Сравниваем строку с ее обратной версией
    # Срезы [::-1] создают обратную копию строки
    return cleaned_text == cleaned_text[::-1]

# Пример использования
test_strings = ["А роза упала на лапу Азора", "hello", "radar", "мадам"]

for test in test_strings:
    result = is_palindrome(test)
    print(f"'{test}' - палиндром: {result}")
```

### Теоретическое задание:
```
ДЕРЕВО с корнем:

        A (корень)
       /|\
      B C D (потомки A, дети A)
     / \   \
    E   F   G (листья - узлы без детей)
   / \
  H   I (листья)

Термины:
- Корень (A) - вершина без родителя
- Родитель (предок): A для B,C,D; B для E,F
- Потомок (ребенок): B,C,D для A; E,F для B
- Лист: H, I, F, G, C, D (узлы без детей)
- Внутренний узел: A, B, E (узлы с детьми)
```

---

## Решения для Ученика 10

### Практическое задание:
```python
def find_difference(list1, list2):
    """
    Находит элементы, которые есть в первом списке, но отсутствуют во втором.
    
    Args:
        list1: первый список
        list2: второй список
        
    Returns:
        Список уникальных элементов из list1, которых нет в list2
    """
    # Преобразуем второй список в множество для быстрого поиска
    set2 = set(list2)
    
    # Используем list comprehension для фильтрации
    # Условие: элемент есть в list1 и отсутствует в set2
    difference = [item for item in list1 if item not in set2]
    
    return difference

# Пример использования
list_a = [1, 2, 3, 4, 5, 6, 7]
list_b = [2, 4, 6, 8, 10]

result = find_difference(list_a, list_b)
print(f"Первый список: {list_a}")
print(f"Второй список: {list_b}")
print(f"Элементы из первого, которых нет во втором: {result}")
```

### Теоретическое задание:
```
ХЕШ-ТАБЛИЦА с разрешением коллизий методом цепочек:

Индексы: 0    1    2    3    4    5    6
        ┌───┬───┬───┬───┬───┬───┬───┐
        │   │   │   │ • │   │   │   │
        └───┴───┴─│─┴───┴───┴───┴───┘
                  │
                  ▼
                "cat" → "dog" → "elephant" (цепочка)

Коллизия: разные ключи дают одинаковый хеш-код
(например, "cat", "dog", "elephant" → хеш=3)

Метод цепочек: каждый слот содержит список (цепочку)
элементов с одинаковым хешем.

Поиск "dog":
1. Вычисляем хеш("dog") = 3
2. Идем в слот 3
3. Ищем в цепочке: "cat" → "dog" → "elephant"
4. Нашли "dog" на 2-й позиции в цепочке
```

---

## Решения для Ученика 11

### Практическое задание:
```python
def count_frequency(numbers):
    """
    Подсчитывает, сколько раз каждое число встречается в списке.
    
    Args:
        numbers: список чисел
        
    Returns:
        Словарь {число: количество}
    """
    frequency = {}
    
    for num in numbers:
        # Увеличиваем счетчик для текущего числа
        # Метод get возвращает 0 если числа еще нет в словаре
        frequency[num] = frequency.get(num, 0) + 1
    
    return frequency

# Пример использования
numbers_list = [1, 2, 3, 2, 1, 3, 3, 4, 5, 4, 4, 4, 2]
result = count_frequency(numbers_list)
print(f"Список: {numbers_list}")
print(f"Частота элементов:")
for num, count in result.items():
    print(f"  {num}: {count} раз(а)")
```

### Теоретическое задание:
```
ПОЛНОЕ БИНАРНОЕ ДЕРЕВО глубины 3:

Уровень 0:        1
                 / \
                /   \
Уровень 1:     2     3
              / \   / \
Уровень 2:   4   5 6   7
            / \ / \
Уровень 3: 8 9 A B

Все уровни, кроме последнего, полностью заполнены.
Все узлы на последнем уровне расположены как можно левее.

Свойства:
- Количество узлов на уровне i: 2^i
- Общее количество узлов глубины h: 2^(h+1) - 1
- Для глубины 3: максимум 15 узлов
```

---

## Решения для Ученика 12

### Практическое задание:
```python
def reverse_list(lst):
    """
    Разворачивает список в обратном порядке без использования reverse().
    
    Args:
        lst: исходный список
        
    Returns:
        Развернутый список
    """
    # Создаем пустой список для результата
    reversed_lst = []
    
    # Идем по исходному списку с конца
    for i in range(len(lst) - 1, -1, -1):
        reversed_lst.append(lst[i])
    
    return reversed_lst

# Альтернативный способ (более питонический)
def reverse_list_slice(lst):
    """Разворачивает список с использованием срезов."""
    return lst[::-1]

# Пример использования
original = [1, 2, 3, 4, 5, 6]
result = reverse_list(original)
print(f"Исходный список: {original}")
print(f"Развернутый список: {result}")
```

### Теоретическое задание:
```
ПРЕДВАРИТЕЛЬНЫЙ ОБХОД (PRE-ORDER) бинарного дерева:
Порядок: Корень → Левое поддерево → Правое поддерево

        A
       / \
      B   C
     / \   \
    D   E   F

Обход pre-order:
1. Посещаем корень: A
2. Обходим левое поддерево B:
   - Посещаем B (корень поддерева)
   - Обходим левое поддерево D: D
   - Обходим правое поддерево E: E
3. Обходим правое поддерево C:
   - Посещаем C
   - Обходим правое поддерево F: F

Результат: A, B, D, E, C, F

Применение: создание копии дерева, сериализация
```

---

## Решения для Ученика 13

### Практическое задание:
```python
def merge_dicts(dict1, dict2):
    """
    Объединяет два словаря. При совпадении ключей суммирует значения.
    
    Args:
        dict1: первый словарь
        dict2: второй словарь
        
    Returns:
        Объединенный словарь
    """
    # Создаем копию первого словаря
    result = dict1.copy()
    
    # Добавляем элементы из второго словаря
    for key, value in dict2.items():
        if key in result:
            # Если ключ уже есть, суммируем значения
            result[key] += value
        else:
            # Если ключа нет, добавляем пару ключ-значение
            result[key] = value
    
    return result

# Пример использования
dict_a = {"a": 10, "b": 20, "c": 30}
dict_b = {"b": 5, "c": 15, "d": 25}

result = merge_dicts(dict_a, dict_b)
print(f"Первый словарь: {dict_a}")
print(f"Второй словарь: {dict_b}")
print(f"Объединенный словарь: {result}")
```

### Теоретическое задание:
```
ЦИКЛИЧЕСКИЙ ГРАФ:

  A → B
  ↑   ↓
  D ← C

Ребра: A→B, B→C, C→D, D→A

ЦИКЛ: последовательность вершин, где первая и последняя вершина совпадают
A → B → C → D → A (цикл длины 4)

Типы графов:
- Ациклический: не содержит циклов (деревья)
- Циклический: содержит хотя бы один цикл

Обнаружение циклов важно для:
- Поиска бесконечных циклов в программах
- Проверки deadlock в операционных системах
- Анализа зависимостей
```

---

## Решения для Ученика 14

### Практическое задание:
```python
def find_primes_in_range(start, end):
    """
    Находит все простые числа в заданном диапазоне.
    
    Args:
        start: начало диапазона (включительно)
        end: конец диапазона (включительно)
        
    Returns:
        Список простых чисел
    """
    # Используем решето Эратосфена для оптимизации
    if end < 2:
        return []
    
    # Создаем множество чисел от 2 до end
    primes = set(range(max(2, start), end + 1))
    
    # Для оптимизации проверяем только до квадратного корня из end
    for i in range(2, int(end**0.5) + 1):
        if i in primes or i >= start:
            # Удаляем кратные i (начиная с i*i)
            multiples = set(range(i*i, end + 1, i))
            primes -= multiples
    
    # Преобразуем обратно в отсортированный список
    return sorted(list(primes))

# Пример использования
start_num, end_num = 10, 50
result = find_primes_in_range(start_num, end_num)
print(f"Простые числа в диапазоне от {start_num} до {end_num}:")
print(result)
```

### Теоретическое задание:
```
СТЕК ВЫЗОВОВ для factorial(4):

1. factorial(4) вызывается
   Стек: factorial(4) [n=4, ждет вычисления 4 * factorial(3)]

2. factorial(3) вызывается из factorial(4)
   Стек: factorial(4) [n=4]
         factorial(3) [n=3, ждет 3 * factorial(2)]

3. factorial(2) вызывается из factorial(3)
   Стек: factorial(4) [n=4]
         factorial(3) [n=3]
         factorial(2) [n=2, ждет 2 * factorial(1)]

4. factorial(1) вызывается из factorial(2)
   Стек: factorial(4) [n=4]
         factorial(3) [n=3]
         factorial(2) [n=2]
         factorial(1) [n=1, возвращает 1]

5. factorial(1) завершается, возвращает 1
   Стек: factorial(4) [n=4]
         factorial(3) [n=3]
         factorial(2) [n=2, вычисляет 2 * 1 = 2]

6. factorial(2) завершается, возвращает 2
   Стек: factorial(4) [n=4]
         factorial(3) [n=3, вычисляет 3 * 2 = 6]

7. factorial(3) завершается, возвращает 6
   Стек: factorial(4) [n=4, вычисляет 4 * 6 = 24]

8. factorial(4) завершается, возвращает 24
   Стек: пустой

Результат: 24
```

---

## Решения для Ученика 15

### Практическое задание:
```python
def group_words_by_length(words):
    """
    Группирует слова по их длине.
    
    Args:
        words: список слов
        
    Returns:
        Словарь {длина: [список слов]}
    """
    grouped = {}
    
    for word in words:
        length = len(word)
        
        # Если длины еще нет в словаре, создаем пустой список
        if length not in grouped:
            grouped[length] = []
        
        # Добавляем слово в список для соответствующей длины
        grouped[length].append(word)
    
    return grouped

# Пример использования
word_list = ["я", "код", "стол", "дом", "питон", "программа", "да", "алгоритм"]
result = group_words_by_length(word_list)

print("Слова, сгруппированные по длине:")
for length, words in sorted(result.items()):
    print(f"  Длина {length}: {words}")
```

### Теоретическое задание:
```
Разница между ДЕРЕВОМ и ГРАФОМ:

ДЕРЕВО:
- Иерархическая структура
- Единственный корневой узел
- Нет циклов
- Между любыми двумя узлами ровно один путь
- N узлов, N-1 ребер

        A
       / \
      B   C
     / \   \
    D   E   F

ГРАФ:
- Более общая структура
- Может быть несколько компонент связности
- Могут быть циклы
- Между узлами может быть несколько путей
- Любое количество ребер

  A --- B
  | \   |
  |  \  |
  D---C---E
      |
      F

Дерево - это частный случай графа (связный ациклический граф).
```

---

## Решения для Ученика 16

### Практическое задание:
```python
def intersection_of_three_sets(set1, set2, set3):
    """
    Находит пересечение трех множеств.
    
    Args:
        set1, set2, set3: три множества
        
    Returns:
        Множество общих элементов
    """
    # Способ 1: последовательное пересечение
    temp_intersection = set1 & set2
    result = temp_intersection & set3
    
    # Способ 2: с использованием встроенной функции
    # result = set1.intersection(set2, set3)
    
    return result

# Пример использования
a = {1, 2, 3, 4, 5, 6}
b = {2, 3, 5, 7, 8, 9}
c = {1, 3, 5, 7, 9, 11}

result = intersection_of_three_sets(a, b, c)
print(f"Множество A: {a}")
print(f"Множество B: {b}")
print(f"Множество C: {c}")
print(f"Пересечение всех трех: {result}")
```

### Теоретическое задание:
```
ДВОИЧНАЯ КУЧА MIN-HEAP для [3, 9, 5, 17, 10, 11]:

Свойство кучи: значение в родителе ≤ значению в детях

Индексация (начиная с 1 для простоты):
1. 3 (корень)
2. 9 (левый ребенок 3)
3. 5 (правый ребенок 3)
4. 17 (левый ребенок 9)
5. 10 (правый ребенок 9)
6. 11 (левый ребенок 5)

Графически:

          3(1)
         /    \
       9(2)    5(3)
      /   \    /
    17(4) 10(5) 11(6)

В скобках - индексы в массиве.

Свойства:
- parent(i) = i//2
- left_child(i) = 2*i
- right_child(i) = 2*i + 1

Минимальный элемент всегда в корне (3).
```

---

## Решения для Ученика 17

### Практическое задание:
```python
def sort_strings_by_length(strings):
    """
    Сортирует список строк по длине в порядке убывания.
    
    Args:
        strings: список строк
        
    Returns:
        Отсортированный список
    """
    # Сортируем по длине строки (ключ len), в обратном порядке (reverse=True)
    sorted_strings = sorted(strings, key=len, reverse=True)
    return sorted_strings

# Пример использования
string_list = ["яблоко", "кот", "программирование", "дом", "алгоритм", "питон"]
result = sort_strings_by_length(string_list)

print("Строки, отсортированные по длине (от самой длинной к самой короткой):")
for s in result:
    print(f"  '{s}' - длина {len(s)}")
```

### Теоретическое задание:
```
ВЗВЕШЕННЫЙ ГРАФ с кратчайшим путем:

Вершины: A, B, C, D, E
Ребра с весами:
A-B: 4, A-C: 2, B-C: 1, B-D: 5, C-D: 8, C-E: 10, D-E: 2, B-E: 3

Графически:

       4
    A-----B
    |\   /|\
   2| \1 | |3
    |  \ | |
    C---\|/ E
    \  8 |  /
     \   | /2
      \  |/
        D

Кратчайший путь из A в E:
1. A→C (2)
2. C→B (1) 
3. B→E (3)
Итого: 2+1+3 = 6

Альтернативные пути:
- A→B→E: 4+3=7
- A→C→E: 2+10=12
- A→C→D→E: 2+8+2=12

Алгоритмы поиска кратчайшего пути: Дейкстра, A*
```

---

## Решения для Ученика 18

### Практическое задание:
```python
def flatten_list(nested_list):
    """
    Преобразует список списков в один плоский список.
    
    Args:
        nested_list: список, содержащий списки
        
    Returns:
        Плоский список
    """
    flat_list = []
    
    for sublist in nested_list:
        # Проверяем, является ли элемент списком
        if isinstance(sublist, list):
            # Если да, добавляем все его элементы
            flat_list.extend(sublist)
        else:
            # Если нет, добавляем сам элемент
            flat_list.append(sublist)
    
    return flat_list

# Пример использования
nested = [[1, 2, 3], [4, 5], [6, 7, 8, 9], 10]
result = flatten_list(nested)
print(f"Вложенный список: {nested}")
print(f"Плоский список: {result}")
```

### Теоретическое задание:
```
AVL-ДЕРЕВО - сбалансированное бинарное дерево поиска:

После вставки 1, 2, 3, 4, 5, 6:

1. Вставка 1:    1
2. Вставка 2:    1
                   \
                    2
3. Вставка 3:    1   (несбалансировано: высота правого поддерева = 2)
                   \
                    2
                     \
                      3
   Балансировка (правый поворот):    2
                                     / \
                                    1   3
4. Вставка 4:    2
                 / \
                1   3
                     \
                      4
5. Вставка 5:    2    (несбалансировано в узле 3)
                 / \
                1   3
                     \
                      4
                       \
                        5
   Балансировка (левый-правый поворот):    2
                                           / \
                                          1   4
                                             / \
                                            3   5
6. Вставка 6:    2
                 / \
                1   4
                   / \
                  3   5
                       \
                        6

AVL-дерево поддерживает баланс: для каждого узла разница высот
левого и правого поддеревьев не более 1.
```

---

## Решения для Ученика 19

### Практическое задание:
```python
def are_anagrams(word1, word2):
    """
    Проверяет, являются ли два слова анаграммами.
    
    Args:
        word1: первое слово
        word2: второе слово
        
    Returns:
        True если слова - анаграммы, иначе False
    """
    # Убираем пробелы и приводим к нижнему регистру
    cleaned_word1 = word1.replace(" ", "").lower()
    cleaned_word2 = word2.replace(" ", "").lower()
    
    # Проверяем длины
    if len(cleaned_word1) != len(cleaned_word2):
        return False
    
    # Сортируем буквы и сравниваем
    return sorted(cleaned_word1) == sorted(cleaned_word2)

# Пример использования
test_pairs = [
    ("listen", "silent"),
    ("triangle", "integral"),
    ("apple", "pale"),
    ("Dormitory", "Dirty room"),
    ("hello", "world")
]

for w1, w2 in test_pairs:
    result = are_anagrams(w1, w2)
    print(f"'{w1}' и '{w2}': {result}")
```

### Теоретическое задание:
```
ПОИСК В ШИРИНУ (BFS) на графе:

Граф:
  A --- B --- C
  |     |     |
  D --- E --- F

Начинаем с вершины A:

1. Посещаем A: [A]
   Очередь: [A]
   
2. Обрабатываем A:
   Соседи A: B, D
   Очередь: [B, D]
   Посещенные: [A, B, D]
   
3. Обрабатываем B:
   Соседи B: A, C, E (A уже посещена)
   Очередь: [D, C, E]
   Посещенные: [A, B, D, C, E]
   
4. Обрабатываем D:
   Соседи D: A, E (оба уже посещены)
   Очередь: [C, E]
   
5. Обрабатываем C:
   Соседи C: B, F (B уже посещена)
   Очередь: [E, F]
   Посещенные: [A, B, D, C, E, F]
   
6. Обрабатываем E:
   Соседи E: B, D, F (все уже посещены)
   Очередь: [F]
   
7. Обрабатываем F:
   Соседи F: C, E (оба уже посещены)
   Очередь: []

Порядок обхода BFS: A, B, D, C, E, F
```

---

## Решения для Ученика 20

### Практическое задание:
```python
def find_top_three(numbers):
    """
    Находит три самых больших числа в списке без полной сортировки.
    
    Args:
        numbers: список чисел
        
    Returns:
        Список трех самых больших чисел в порядке убывания
    """
    if len(numbers) < 3:
        return sorted(numbers, reverse=True)
    
    # Инициализируем три переменные для хранения наибольших значений
    first = second = third = float('-inf')
    
    for num in numbers:
        if num > first:
            # Нашли новый максимум, сдвигаем значения
            third = second
            second = first
            first = num
        elif num > second and num != first:
            # Нашли новое второе значение
            third = second
            second = num
        elif num > third and num != second and num != first:
            # Нашли новое третье значение
            third = num
    
    return [first, second, third]

# Пример использования
numbers_list = [10, 4, 78, 34, 92, 15, 67, 43]
result = find_top_three(numbers_list)
print(f"Список: {numbers_list}")
print(f"Три самых больших числа: {result}")
```

### Теоретическое задание:
```
ПРЕФИКСНОЕ ДЕРЕВО (TRIE) для слов: cat, car, dog, dot:

Корень (пустая строка)
    |
    c---------d
    |         |
    a         o
   / \       / \
  t   r     g   t
  |   |     |   |
 cat car   dog dot

Структура узла:
- Дети: словарь или массив ссылок на дочерние узлы
- Флаг конца слова

Поиск слов:
1. "cat": c → a → t (флаг конца слова = True)
2. "car": c → a → r (флаг конца слова = True)
3. "ca": c → a (флаг конца слова = False - не полное слово)
4. "do": d → o (флаг конца слова = False - не полное слово)

Преимущества trie:
- Быстрый поиск по префиксу
- Эффективное хранение слов с общими префиксами
- Автодополнение, проверка орфографии
```

---
